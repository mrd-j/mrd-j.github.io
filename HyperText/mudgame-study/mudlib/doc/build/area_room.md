## 关于Area环境模式

在游戏环境开发的教程中我们演示过游戏环境是怎么实现的，任何对象都可以是环境，在常规的MUD开发中，我们每个ROOM对应一个文件，多个ROOM组合成一个AREA，所有AREA构成游戏世界。这种模式的优势是实现起来非常简单，但是如果世界复杂，需要太多的文件了，当然，也是有解决方案的，使用虚拟对象，而且通过虚拟对象甚至可以一个文件就是一个世界，但不管是实现对象文件还是虚拟对象，都有一个问题：在相同环境之中的玩家之间没有距离的概念，如果从坐标上看，大家都在一个坐标点上，每个ROOM对应一个坐标，因为不同ROOM是不同的文件对象，不同坐标点都是独立的环境，如果是在室内，还没什么问题，但在室外，同一条街的人无法看到不在一个坐标点的玩家，这就很奇怪了。

如何让同在一条街上不同坐标点的玩家可以看到对方，如何实现环境的距离概念？换一个思路：我们可以把一个文件对应一个房间设计为一个文件对应一个地区，引入坐标参数到内容物身上，而不是坐标参数在环境ROOM身上，注意这和虚拟对象有本质的区别，虚拟对象只是让一个真实的文件复制为多个虚拟的游戏对象，在游戏中体现为多个对象，每个对象代表的还是一个坐标点。

这样设计的优势是环境对象文件大大减小，一个城市一个文件，而不是一个坐标一个文件，另外也可以轻易的实现同一环境中距离的概念。劣势是对个环境文件代码的复杂度大大的提升，而且目前游戏提供的很多外部函数需要做重写，否则会出现奇怪的问题，如say说话会变成整个地区的人都能听到，和你需求的不太一样。

相对普通模式Area模式的主要不同点：

1. go移动不再是调用move_object函数把玩家从一个环境对象移动到另一个环境对象，而是没有移动真实环境对象，只是改变被移动对象的坐标参数
2. 手动调用init()方法，因为移动没有move_object()，不会触发init，需要我们获取需要触发的对象来调用这个方法
3. tell_room()的实际作用成了tell_area()，我们需要重写方法，根据坐标判断消息接受范围，另外需要重写的类似函数还有：say、present

在开发上，需要重写go、look等和环境及移动相关的指令，对area模式做特殊处理，这些指令还包括goto、get等等，另外需要增加区域模式的判断。
